# 概述

总体来看，排序算法大致可分为十类：

- 选泡插：选择排序、冒泡排序、插入排序
- 快归希堆：快速排序、归并排序、希尔排序、堆排序
- 桶计基：桶排序、计数排序、基数排序

- - - 

# 时间复杂度O(n^2)级排序算法

## 冒泡排序

冒泡排序是入门级的算法，但也有一些有趣的玩法。通常来说，冒泡排序有三种写法：

- 一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位；
- 经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序；
- 进一步优化的写法：除了使用变量记录当前轮次是否发生交换外，再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较。

### 冒泡第一种写法

```C++
void bubbleSort(vector<int>& arr) {
    for (int i =0; i < arr.size() - 1; i ++) {
        for (int j = 0; j < arr.size() - 1 - i; j ++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

```

最外层的 for 循环每经过一轮，剩余数字中的最大值就会被移动到当前轮次的最后一位，中途也会有一些相邻的数字经过交换变得有序。总共比较次数是 (n-1)+(n-2)+(n-3)+…+1(n−1)+(n−2)+(n−3)+…+1。

这种写法相当于相邻的数字两两比较，并且规定：“谁大谁站右边”。经过 n-1n−1 轮，数字就从小到大排序完成了。整个过程看起来就像一个个气泡不断上浮，这也是“冒泡排序法”名字的由来。

### 冒泡排序的第二种写法

```C++
void bubbleSort(vector<int>& arr) {
    // 初始时 swapped 为 true，否则排序过程无法启动
    bool swapped = true;
    for (int i = 0; i < arr.size() - 1; i ++) {
        // 如果没有发生过交换，说明剩余部分已经有序，排序完成
        if (!swapped) {
            break;
        }
        // 设置 swapped 为 false，如果发生交换，则将其置为 true
        swapped = false;
        for (int j = 0; j < arr.size() - 1 - i; j ++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
    }
}
```

最外层的 for 循环每经过一轮，剩余数字中的最大值仍然是被移动到当前轮次的最后一位。这种写法相对于第一种写法的优点是：如果一轮比较中没有发生过交换，则立即停止排序，因为此时剩余数字一定已经有序了。

![](https://pic.leetcode-cn.com/1643081284-zuFckJ-1.1.gif)

冒泡排序的时间复杂度O(n^2)，空间复杂度O(1)。

## 选择排序

选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。

```C++
void selectionSort(vector<int>& arr) {
    int minIndex;
    for (int i = 0; i < arr.size() - 1; i++) {
        minIndex = i;
        for (int j = i + 1; j < arr.size(); j++) {
            if (arr[minIndex] > arr[j]) {
                // 记录最小值的下标
                minIndex = j;
            }
        }
        // 将最小元素交换至首位
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}

```

![](https://pic.leetcode-cn.com/1611226680-vyvgVL-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-1.gif)


选择排序的时间复杂度O(n^2)，空间复杂度O(1)。但选择排序是不稳定的。

## 插入排序

在一个有序序列中，将后续到来的待排序的元素插入到合适的位置。

插入排序有两种写法：

- 交换法：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。
- 移动法：在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。

```C++
// 交换法

void insertSort(vector<int>& arr) {
    // 从第二个数开始，往前插入数字
    for (int i = 1; i < arr.size(); i++) {
        // j 记录当前数字下标
        int j = i;
        // 当前数字比前一个数字小，则将当前数字与前一个数字交换
        while (j >= 1 && arr[j] < arr[j - 1]) {
            swap(arr, j, j - 1);
            // 更新当前数字下标
            j--;
        }
    }
}
// 当数字少于两个时，不存在排序问题，当然也不需要插入，所以我们直接从第二个数字开始往前插入。

// 移动法

void insertSort(vector<int>& arr) {
    // 从第二个数开始，往前插入数字
    for (int i = 1; i < arr.size(); i++) {
        int currentNumber = arr[i];
        int j = i - 1;
        // 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪
        while (j >= 0 && currentNumber < arr[j]) {
            arr[j + 1] = arr[j];
            j--;
        }
        // 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。
        // 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。
        arr[j + 1] = currentNumber;
    }
}

```

![](https://pic.leetcode-cn.com/1643081593-BRjzFN-insert.gif)

插入排序过程需要两层循环，时间复杂度为O(n^2)；只需要常量级的临时变量，空间复杂度为O(1)。插入排序是一种稳定的排序算法。

- - -

# 时间复杂度 O(nlogn) 级排序算法

## 希尔排序

希尔排序本质上是对插入排序的一种优化，它利用了插入排序的简单，又克服了插入排序每次只交换相邻两个元素的缺点。它的基本思想是：

- 将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组
- 逐渐缩小间隔进行下一轮排序
- 最后一轮时，取间隔为 11，也就相当于直接使用插入排序。但这时经过前面的「宏观调控」，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成

![](https://pic.leetcode-cn.com/1643081683-ORhiPp-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif)

其中，每一遍排序的间隔在希尔排序中被称之为增量，所有的增量组成的序列称之为增量序列，也就是本例中的 [5, 2, 1][5,2,1]。增量依次递减，最后一个增量必须为 11，所以希尔排序又被称之为「缩小增量排序」。要是以专业术语来描述希尔排序，可以分为以下两个步骤：
