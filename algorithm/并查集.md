# 概述

并查集主要解决一些元素分组的问题，管理一系列不想交的集合，主要解决一些“动态连通性问题”，并支持两种操作：

- 合并Union：把两个不相交的集合合并为一个集合；
- 查询Find：查询两个元素是否在同一个集合中。

实现三个api：

```C++
class UF {
    public:
        /* 将 p 和 q 连接 */
        void union(int p, int q);
        /* 判断 p 和 q 是否连通 */
        bool connected(int p, int q);
        /* 返回图中有多少个连通分量 */
        int count();
}
```

# 基本操作

并查集的数据结构可以用树和森林的形式进行抽象，用数组来具现化这个森林。

```C++
class UF {
    // 记录连通分量
    private:
        int count;
    // 节点 x 的节点是 parent[x]
        int *parent;

    /* 构造函数，n 为图的节点总数 */
    public:
        void UF(int n) {
            // 一开始互不连通
            count = n;
            // 父节点指针初始指向自己
            parent = malloc(sizeof(int) * n);
            for (int i = 0; i < n; i++)
                parent[i] = i;
        }

    /* 其他函数 */
}
```

如果某两个节点被连通，则让其中（任意）一个节点接到另一个节点的根节点上。

```C++
void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ) {
        return;
    }
    // 将两棵树合并为一棵
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP 也一样
    count--; // 两个分量合二为一
} 

/* 返回某个节点 x 的根节点 */
int find(int x) {
    // 根节点的 parent[x] == x
    while (parent[x] != x)
        x = parent[x];
    return x;
}

/* 返回当前的连通分量个数 */
int count() { 
    return count;
}

/*如果节点p和q连通的话，它们一定拥有相同的根节点*/
boolean connected(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    return rootP == rootQ;
}
```

# 平衡性优化

